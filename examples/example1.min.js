/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	const {div, h1, h2} = __webpack_require__(1)
	const {render} = __webpack_require__(2)
	
	const App = (props, children = []) => {
	  return div({ 
	    style: {
	      margin: '0'
	    }
	  }, [
	    h1({}, props.header),
	    h2({}, props.subheader),
	  ])
	}
	
	document.getElementById('app').innerHTML = render(App({
	  header: 'App Title',
	  subheader: 'Subheader'
	}))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	const {createComponent} = __webpack_require__(2)
	
	const htmlTags = [
	  'a',
	  'b',
	  'i',
	  'p',
	  'br',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'hr',
	  'li',
	  'ol',
	  'ul',
	  'div',
	  'html',
	  'head',
	  'body',
	  'link',
	  'script',
	  'style',
	  'footer',
	  'form',
	  'label',
	  'span',
	  'table',
	  'header',
	  'main',
	  'section',
	  'strong',
	  'template',
	  'aside',
	  'details',
	  'dialog',
	  'summary',
	  'meta',
	  'base',
	  'noscript',
	  'embed',
	  'object',
	  'param',
	]
	
	// create methods for all html tags
	let HTML = {}
	htmlTags.forEach((tag) => {
	  HTML[tag] = createComponent(tag)
	})
	
	module.exports = HTML

/***/ },
/* 2 */
/***/ function(module, exports) {

	const renderProps = (props) => {
	  if (props && typeof props === 'object' && Object.keys(props).length) {
	    return ' ' + Object.keys(props)
	      .filter((key) => props[key])    // filter out undefined values
	      .map((key) => `${key}="${props[key]}"`).join(' ')
	  }
	  return ''
	}
	
	const recursiveRender = ({tag, props, children}, depth = 0) => {
	  let spacing = '';
	  for (let i = 0; i < depth; i++) {
	    spacing += '  ';
	  }
	
	  // every tag except the first one should have an endline in front of it
	  let firstEndline = depth > 0 ? '\n' : ''
	  
	  depth++
	  
	  let renderedChildren = ''
	  let lastEndline = ''
	  switch(typeof children) {
	    case 'undefined':
	      break
	    case 'string':
	      renderedChildren = children
	      break
	    default:  //object
	      if (!Array.isArray(children)) {
	        var err = new Error();
	        throw `Non-array passed to ${tag} element`
	      }
	      renderedChildren = children.map((child) => {
	        return recursiveRender(child, depth)
	      }).join('')
	    
	      // add extra endline if element has children
	      lastEndline = renderedChildren ? ('\n' + spacing) : ''
	      break
	  }
	
	
	
	  return `${firstEndline}${spacing}<${tag}${renderProps(props)}>${renderedChildren}${lastEndline}</${tag}>`
	}
	
	const createComponent = (tag) => (props = {}, children = []) => {
	  return {
	    tag: tag,
	    props: props,
	    children: children
	  }
	}
	
	module.exports = {
	  createComponent: createComponent,
	  render: recursiveRender
	}

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTg3NGQyZGI3NzgyZTNlOTBkNmEiLCJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZXhhbXBsZTEuanMiLCJ3ZWJwYWNrOi8vLy4vSHRtbC5qcyIsIndlYnBhY2s6Ly8vLi94bWV0YWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0Q0EsUUFBTyxZQUFZO0FBQ25CLFFBQU8sT0FBTzs7QUFFZDtBQUNBLGU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsVUFBUztBQUNULFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDakJELFFBQU8sZ0JBQWdCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxzQjs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLElBQUksSUFBSSxXQUFXO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0Esa0JBQWlCLFdBQVc7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsYUFBWSxhQUFhLEVBQUUsUUFBUSxHQUFHLElBQUksRUFBRSxtQkFBbUIsR0FBRyxpQkFBaUIsRUFBRSxZQUFZLElBQUksSUFBSTtBQUN6Rzs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEUiLCJmaWxlIjoiZXhhbXBsZTEubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA1ODc0ZDJkYjc3ODJlM2U5MGQ2YVxuICoqLyIsImNvbnN0IHtkaXYsIGgxLCBoMn0gPSByZXF1aXJlKCcuLi9IdG1sJylcbmNvbnN0IHtyZW5kZXJ9ID0gcmVxdWlyZSgnLi4veG1ldGFsJylcblxuY29uc3QgQXBwID0gKHByb3BzLCBjaGlsZHJlbiA9IFtdKSA9PiB7XG4gIHJldHVybiBkaXYoeyBcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9XG4gIH0sIFtcbiAgICBoMSh7fSwgcHJvcHMuaGVhZGVyKSxcbiAgICBoMih7fSwgcHJvcHMuc3ViaGVhZGVyKSxcbiAgXSlcbn1cblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpLmlubmVySFRNTCA9IHJlbmRlcihBcHAoe1xuICBoZWFkZXI6ICdBcHAgVGl0bGUnLFxuICBzdWJoZWFkZXI6ICdTdWJoZWFkZXInXG59KSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZXhhbXBsZXMvZXhhbXBsZTEuanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJjb25zdCB7Y3JlYXRlQ29tcG9uZW50fSA9IHJlcXVpcmUoJy4veG1ldGFsJylcblxuY29uc3QgaHRtbFRhZ3MgPSBbXG4gICdhJyxcbiAgJ2InLFxuICAnaScsXG4gICdwJyxcbiAgJ2JyJyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hyJyxcbiAgJ2xpJyxcbiAgJ29sJyxcbiAgJ3VsJyxcbiAgJ2RpdicsXG4gICdodG1sJyxcbiAgJ2hlYWQnLFxuICAnYm9keScsXG4gICdsaW5rJyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdsYWJlbCcsXG4gICdzcGFuJyxcbiAgJ3RhYmxlJyxcbiAgJ2hlYWRlcicsXG4gICdtYWluJyxcbiAgJ3NlY3Rpb24nLFxuICAnc3Ryb25nJyxcbiAgJ3RlbXBsYXRlJyxcbiAgJ2FzaWRlJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ3N1bW1hcnknLFxuICAnbWV0YScsXG4gICdiYXNlJyxcbiAgJ25vc2NyaXB0JyxcbiAgJ2VtYmVkJyxcbiAgJ29iamVjdCcsXG4gICdwYXJhbScsXG5dXG5cbi8vIGNyZWF0ZSBtZXRob2RzIGZvciBhbGwgaHRtbCB0YWdzXG5sZXQgSFRNTCA9IHt9XG5odG1sVGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgSFRNTFt0YWddID0gY3JlYXRlQ29tcG9uZW50KHRhZylcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9IdG1sLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiY29uc3QgcmVuZGVyUHJvcHMgPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzICYmIHR5cGVvZiBwcm9wcyA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiAnICcgKyBPYmplY3Qua2V5cyhwcm9wcylcbiAgICAgIC5maWx0ZXIoKGtleSkgPT4gcHJvcHNba2V5XSkgICAgLy8gZmlsdGVyIG91dCB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAubWFwKChrZXkpID0+IGAke2tleX09XCIke3Byb3BzW2tleV19XCJgKS5qb2luKCcgJylcbiAgfVxuICByZXR1cm4gJydcbn1cblxuY29uc3QgcmVjdXJzaXZlUmVuZGVyID0gKHt0YWcsIHByb3BzLCBjaGlsZHJlbn0sIGRlcHRoID0gMCkgPT4ge1xuICBsZXQgc3BhY2luZyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspIHtcbiAgICBzcGFjaW5nICs9ICcgICc7XG4gIH1cblxuICAvLyBldmVyeSB0YWcgZXhjZXB0IHRoZSBmaXJzdCBvbmUgc2hvdWxkIGhhdmUgYW4gZW5kbGluZSBpbiBmcm9udCBvZiBpdFxuICBsZXQgZmlyc3RFbmRsaW5lID0gZGVwdGggPiAwID8gJ1xcbicgOiAnJ1xuICBcbiAgZGVwdGgrK1xuICBcbiAgbGV0IHJlbmRlcmVkQ2hpbGRyZW4gPSAnJ1xuICBsZXQgbGFzdEVuZGxpbmUgPSAnJ1xuICBzd2l0Y2godHlwZW9mIGNoaWxkcmVuKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlblxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OiAgLy9vYmplY3RcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgICAgICB0aHJvdyBgTm9uLWFycmF5IHBhc3NlZCB0byAke3RhZ30gZWxlbWVudGBcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgIHJldHVybiByZWN1cnNpdmVSZW5kZXIoY2hpbGQsIGRlcHRoKVxuICAgICAgfSkuam9pbignJylcbiAgICBcbiAgICAgIC8vIGFkZCBleHRyYSBlbmRsaW5lIGlmIGVsZW1lbnQgaGFzIGNoaWxkcmVuXG4gICAgICBsYXN0RW5kbGluZSA9IHJlbmRlcmVkQ2hpbGRyZW4gPyAoJ1xcbicgKyBzcGFjaW5nKSA6ICcnXG4gICAgICBicmVha1xuICB9XG5cblxuXG4gIHJldHVybiBgJHtmaXJzdEVuZGxpbmV9JHtzcGFjaW5nfTwke3RhZ30ke3JlbmRlclByb3BzKHByb3BzKX0+JHtyZW5kZXJlZENoaWxkcmVufSR7bGFzdEVuZGxpbmV9PC8ke3RhZ30+YFxufVxuXG5jb25zdCBjcmVhdGVDb21wb25lbnQgPSAodGFnKSA9PiAocHJvcHMgPSB7fSwgY2hpbGRyZW4gPSBbXSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlQ29tcG9uZW50OiBjcmVhdGVDb21wb25lbnQsXG4gIHJlbmRlcjogcmVjdXJzaXZlUmVuZGVyXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3htZXRhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=